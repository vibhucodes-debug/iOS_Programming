|||||||||||||||||||||
ARCHITECTURE OF SWIFT 
---------------------

print("Hello, World!")  // The print() function outputs "Hello, World!" in the console/terminal.

Note : The angular brackets '>' in the following examples of this chapter are used to denote a line in a terminal, they are not a part of swift code.

How to write code?
1. A complete swift command is a statement. 
2. Write one statemet in one line
    Example - > print("Hello")  //  First line
              > print("World!)  //  Second line
3. If we combine more than one statement in a line, then we have to put a semicolon(;) between the 2 satements.
    Example - print("Hello, World!"); print("Hello, World")
4. Putting a semicolon(;)  at the end of each statement is not necessary.

||||||||||||||||
--- COMMENTS ---
||||||||||||||||

1. Anything, written after //, or between /* */ is a comment, i.e the rest of the code is not effected by a comment. Programmers usually use comments to elaborate their code or to take notes.
  Example -  > print("Hello, World!) // This is a single line comment.
             > /*
             >  This is a multi-line comment
             > */


How to write code? Continued.

5. A single statement can be broken into multiple lines in order to prevent them from becoming long lines. This is for the purpose of neat and clean code.
  Example - 
            > // Complete statement in one line
            > for i in range{ print(i) } 
            >
            > // For loop statement in multiple lines
            > for i in range {
            >     print(i)
            > }

6. In most coding languages, curly braces are used as delimiters .i.e used for seperation. It is conventional to give a line break after curly braces and, put an indentation (spaces or tabs) for code clarity.
  Example - 
            > for i in range { // line breaks here
            > ---- print("Hello")  // Here, (----) before print() function represents indentation
            > }

7. XCode will automatically impose these conventions but a Swift code doesn't care about line breaks and indentations. For Swift the following code is also acceptable :
            > for i in range{ print(i) }



|||||||||||||||||||
--- COMPILATION ---
|||||||||||||||||||

Swift is a compiled language. 

Code text file is firstly passed through a compiler, and then converted into a low-level language(0s and 1s) that the computer can understand.
A code must build before its actually run. The compiler checks for errors in the code and if it encounters any, an error prompt is thrown to fix it before running the code.



||||||||||||||||||||||||
--- Objects in Swift ---
||||||||||||||||||||||||

In Swift everything is an object. An object is a basic entity/data field that actually exits in the memory. It is based on a blueprint/template that has 
attributes and behaviours(variables and functions) defined as a class.

   > // Blueprint
   > class Car{
   >     var speed = 120
   >     func start(){
   >         print("Vroooom!")
   >     }
   > }    
   > // Object
   > var ferrari = Car()
   

For example, an object is a data field that has properties and behaviours. We can access the properties of an object by using dot-notation.
Example - 
        > Car.speed    // Accessing properties
        > Car.start()  // Calling behaviours

Characteristics of an object 
----------------------------

1. Identity: Every object must have a different identity from the other, known as the object’s name. No two object must have the same name. An identity is basically an objects address in the memory.
2. State: If there are some properties of a class, that is designed to be derived in an object, it must have some values to get initiated (usually done with the help of constructors).
3. Behaviour: Now since the object have a name and some properties, it must have some purpose as well. So these purposes are defined with help of functions (processes) and are known as behaviours.


*** Let's start by stipulating that an object is something that we can send messages to. A message is roughly speaking an instruction. 

Example -  We can give instructions to a car for starting the engine, moving forward, appllying breaks, etc. Here, car acts as an object.

*** The idea of everything being an object is a way of suggesting that even "primitive" linguistic entities can be sent messages. 

Example - 
            1 is nothing just a digit and no more. It's surprising to find that 1             can be followed by a dot and a message in Swift.

          > let d = 1.description

Another example - 
          > let sum = 1 + 2;
        The above line of code is nothing but a trickery. It just says that 1 is an object and, + is a message, but a message of special type(operator syntax).

*** ---- In Swift, every noun is an object and every verb is a message. ---- ***

To test whether everything in swift is an object, we can try to modify it. An object type can be extended in Swift, meaning that we can define our own messages on that type. 
We can change the number type as follows: 

    > extension Int {
    >    func sayHello() {
    >        print("Hello, I'm \(self)")
    >     }
    > }
    >
    > 1.sayHello() // Outputs : "Hello, I'm 1"

In Swift, then, 1 is an object. In some languages, such as Objective-C it clearly is not; it is a "primitive" or scalar built-in data type. In Swift there are no scalar types(primitive); everything is ultimately object types.




|||||||||||||||||||||||||||||||||||||
--- THREE FLAVOURS OF OBJECT TYPE ---
|||||||||||||||||||||||||||||||||||||



Swift has classes but 1 in swift is not a class or an instance of a class. The type of 1 namely Int is a struct and 1 is an instance of a struct. And, swift has yet another type that we can send messages to, called an Enum.

So swift has three kinds of object type : Classes, Structs and Enums.

Classes are reference types whereas, struct and enums are value types. 


|||||||||||||||||
--- VARIABLES ---
|||||||||||||||||

A variable is a name of an object. Technically a variable refers to an object, therefore it is an object reference.
No variable in swift comes implicitly into existence, all variables must be declared.

Declaration is usually accompanied by initialization

    > let one = 1
    > var two = 2
    > two = one

The name one, on the right side of the equal sign, is used merely to refer to the value inside the variable one (namely 1); but the name two, on the left side of the equal sign, is used to replace the value inside the variable two. A statement like that, with a variable name on the left side of an equal sign, is called an assignment, and the equal sign is the assignment operator. The equal sign is not an assertion of equality, as it might be in an algebraic formula; it is a command. It means: “Get the value of what’s on the right side of me, and use it to replace the value of what’s on the left side of me.”

----- LET AND VAR -----
-----------------------

    > let one = 1   // A variable declared with let stays constant
    > var two = 2     
    > one = two     // Throws compiler error

----- Type of a variable ----
-----------------------------

This type is established when the variable is declared and can never change.

    > var two = 2
    > two = "hello"  // Compiler error

*** Variables have a lifetime of their own. As long as a variable exists, it keeps its value alive. Thus a variable can be not only used to name something, but also, a way of preserving it. 



|||||||||||||||||
--- FUNCTIONS ---
|||||||||||||||||

In general executable code lives inside the body of a function A function can be described as a block of code that can be called by its name to perform a certain task, it is designed to perform.

Function declaration : 
        > func go(){
        >     print("Hello, world!")
        > }
        > go() // Calling a function by its name + parenthesis at the end

A function doesn't run own its own it needs to be called.

That is a command to the go function that it should actually run. But again, that com‐ mand is itself executable code, so it cannot live on its own either. It might live in the body of a different function:
   > func doGo() {
   >     go()
   > }

That, too, is just a function declaration; to run it, someone must call doGo by saying doGo(). And that too, must live inside the body of another function, right? All this is becoming like some kind of  infinite regression.
In real life fortunately this problem doest arise. Eventually we have to create an iOS app that will be run on an iOS device(or Simulator) by a runtime that already wants to call certain functions. 

Swift also has a special rule that a file called main.swift, exceptionally, can have executable code at its top level, outside any function body, and this is the code that actually runs when the program runs. 


|||||||||||||||||||||||||||||||||
--- Structure of a Swift file ---
|||||||||||||||||||||||||||||||||

A Swift program consists of one or more files. In Swift, a file is a meaningful unit, and there are definite rules about the structure of the Swift code that can go inside it.

Only certain things can go at the top level of a Swift file. Which are :

    * Module import satements: A module is an even higher-level unit than a swift fil. A module can consist of multiple files, and these files can see eachother automatically. On the other hand, a module cannot see another module without an import statement.

    * Variable declarations: A variable declared at the top level of a file is a global variable. All code will be able to see and access it, without explicitly sending a message to any object, and it lives as long as the program runs.

    * Function declarations: A function declared at the top level of a file is a global function. All code will be able to call it, without explicitly sending messages to any object.

    Object type declarations: The declarations for a class, struct or enum.

        import UIKit
        var one = 1
        func changeOne() {
        }
        class Manny {
        }
        struct Mo{
        }
        enum Jack{
        }

NOTE : We never say that executalbe code can go on the top of a file.


Example of a valid Swift file structure : 

    import UIKit
    var one = 1
    func changeOne(){
        print(one)    // function changeOne has access to variable 'one' that is from a higher level
    }
    class Many{

    }

The curly braces of each of the things in that example can all have variable declarations ,function declarations, and object type declarations within them.

We never say that executable code can go on the top of a file. *** Only a funciton body can contain executable code. 
A statement like one = two or print("Hello) can't got at the top of a file.

    > var one = 1      // executable code can't go here
    > func changeOne(){
    >     let two = 2  // executable code
    >     one = two   // executable code
    > }

Executable code also can't got directly inside the curly braces that accompany a class declaration. Because it is top level of a class body, not a function body. But a class declaration can contain a function declaration and that function declaration can have executable code.

        class Example{
            let name = "Vaibhav"   // executable code can't go here
            func sayName() {
                print(name)   // executable code
            }
        }


Another Example of a legal Swift file : 

    import UIKit 
    var one = 1
    func changeOne() {
        let two = 2
        func sayTwo() {
            print(two)
        }
        class Klass {}
        struct Struct {}
        enum Enum {}
        one = two                
    }
    class Moye {
        let name = "Moye moye"
        func sayName(){
            print(name)
        }
        class Klass {}
        struct Struct {}
        enum Enum {}
    }
    struct Youtube {
        let name = "Youtube"
        func sayName(){
            print(name)
        }
        class Klass {}
        struct Struct {}
        enum Enum {}
    }
    enum Jack {
        var name : String {
            return "Jack"
        }
        func sayName() {
            print(name)
        }
        class Klass {}
        struct Struct {}
        enum Enum {}
    }



||||||||||||||||||||||||||
--- Scope and Lifetime ---
||||||||||||||||||||||||||


In Swift program, things have a scope. This refers to their ability to be seen by other things. These things are nested inside of other things forming a hierarchy of things. The rule is that things can see things at their own level and at a heigher level containing them.

    *  A module is a scope
    *  A file is a scope 
    *  Curly braces are a scope

Inside the declaration of Moye in previous example name is a varaible declaration and sayName is a function declaration. The code inside sayName's curly braces can see code outside those curly braces at a higher containing level. And, can therefore see the name variable.

The code inside the body of the changeOne function can see the one variable declared at the top level of the file. Indeed, everything throughout this file can see the one variable declared at the top level of the file.

* Scope is thus a very important part for sharing information.
    

Things also have a lifetime, which is effectively equivalent to their scope. A thing lives as long as its surrounding scope lives. 
Variable one lives as long as the file lives - namely, as long as the program runs. 
But, the variable name declared at the top of Moye class exists as long as the instance of Moye exists.


* Things declared at a deeper level live even shorter lifetimes. 

full silly() {
    if true {
         class Cat {}
         var one = 1
         one = one + 1
    }
}

The class Cat and the variable one will not even come into existence until someone calls the silly function, and even then they will exist only during the breif instant that the path of code execution passes through the if construct. 
On executing the code, the path of execution follows as shown below :
    Calling function 'silly'  - > If Construct - > Cat is declared and comes into existence - > One is declared - > execution of one = one + 1 -> End of scope - > Cat and one vanish  


\\\\ OBJECT MEMBERS ////

class Moye {
    let name = "Moye"
    func sayName(){
        print(name)
    }
}

* name is a variable declared at the top level of the class, so it is called a Class property of that object.
* sayName is a function declared at the top level of an object declaration, so it is called a method of that object.

Things declared tat the top level of an object declaration - properties, methods and any objects declared at that level - are collectively the members of that object. Mebers have a special significance, because they define the messages you are allowed to send to that object!



||||||||||||||||||
--- NAMESPACES ---
||||||||||||||||||

A namespace is a named region of that program. The names of thins inside a name-space cannot be reached by things outside it without somehow first passing through the barrier of saying that region's name. 
Clearly, namespace and scopes are closely related notations. Moye is a namespace 

    class Moye {
        class Klass {}
    }

    class Manny {
        class Klass {}
    }

Class Manny and Moye have classes with same names declared inside of them but both are not effected because they are declared in different namespaces. Moye is a namespace, and Klass is declared inside of it. Any code inside of Moye, and at the same level as Klass can see Klass, but anything outside of Moye can't see Klass. To access class it first has to call Moye by its name and then use dot notation to call Klass.

    > Moye.Klass





    
